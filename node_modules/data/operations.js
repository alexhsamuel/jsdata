(function () { 
  const assert = require('assert')

  const data = require('data/data')
  const Series = data.Series

  // FIXME: Elsewhere.
  function isIntArray(arr) {
    return (
         arr instanceof Int8Array  || arr instanceof Uint8Array
      || arr instanceof Int16Array || arr instanceof Uint16Array
      || arr instanceof Int32Array || arr instanceof Uint32Array
    )
  }

  function isFloatArray(arr) {
    return arr instanceof Float32Array || arr instanceof Float64Array
  }

  // For now, this is all we got; no way to set a function name dynamically.
  const NAME = Symbol('name')
  function setName(fn, name) { 
    fn[NAME] = name
    return fn
  }

  function binary(op, name) {
    return setName(function (a, b) {
      if (a instanceof Series && b instanceof Series) {
        const labels = a.labels
        assert(Object.is(b.labels, labels))
        const res = new a.values.constructor(a.length)  // FIXME: Coerce types.
        for (let i = 0; i < res.length; ++i) res[i] = op(a.values[i], b.values[i])
        return new Series(labels, res)
      }
      else if (a instanceof Series) {
        const res = new a.values.constructor(a.length)  // FIXME: Coerce types.
        for (let i = 0; i < res.length; ++i) res[i] = op(a.values[i], b)
        return new Series(a.labels, res)
      }
      else if (b instanceof Series) {
        const res = new b.values.constructor(b.length)  // FIXME: Coerce types.
        for (let i = 0; i < res.length; ++i) res[i] = op(a, b.values[i])
        return new Series(b.labels, res)
      }
      else return op(a, b)
    }, name)
  }

  function fold(op, initial, name) {
    return setName(function (ser) {
      let res = initial
      for (let i = 0; i < ser.length; ++i) res = op(res, ser.values[i])
      return res
    }, name)
  }

  function scan(op, initial, name) {
    return setName(function (ser) {
      let val = initial
      let values = ser.values
      let len = values.length
      const res = new values.constructor(len)  // FIXME: Coerce types.
      for (let i = 0; i < len; ++i) res[i] = val = op(val, values[i])
      return new Series(ser.labels, res)
    }, name)
  }

  function filter(series, pred) {
    const len = series.length
    const values = series.values
    const labels = series.key.labels

    const newLabels = new labels.constructor(len)
    const newValues = new values.constructor(len)

    let newLen = 0
    for (let i = 0; i < len; ++i) if (pred(values[i], labels[i])) {
      newLabels[newLen] = labels[i]
      newValues[newLen] = values[i]
      ++newLen
    }

    const key = newLen === len ? series.key 
          : new data.Key(newLabels.slice(0, newLen))
    return new data.Series(key, newValues.slice(0, newLen))
  }

  function map(series, fn) {
    const len = series.length
    const labels = series.key.labels
    const values = series.values
    const res = new series.values.constructor(len)
    for (let i = 0; i < len; ++i) res[i] = fn(values[i], labels[i])
    return new data.Series(series.key, res)
  }

  function reduce(series, acc, initial) {
    const len = series.length
    const labels = series.key.labels
    const values = series.values
    let res = initial
    for (let i = 0; i < len; ++i) res = acc(res, values[i], labels[i])
    return res
  }

  function summarizeFloat(series) {
    const values = series.values
    let min
    let max
    const len = series.length
    let numFinite = 0
    let numNaN = 0
    let sum = 0
    let sum2 = 0

    for (let i = 0; i < len; ++i) {
      const val = values[i]
      if (Number.isFinite(val)) {
        if (numFinite === 0) {
          numFinite = 1
          min = max = val
        }
        else {
          numFinite += 1
          if (val < min) min = val
          if (val > max) max = val
        }
        sum += val
        sum2 += val * val
      }
      else if (isNaN(val)) numNaN += 1
    }

    return {len, numFinite, numNaN, min, max, sum, sum2}
  }

  function summarizeInt(series) {
    const values = series.values
    let min = null
    let max = null
    const len = series.length
    let sum = 0
    let sum2 = 0

    for (let i = 0; i < len; ++i) {
      const val = values[i]
      if (min === null) min = max = val
      else if (val < min) min = val
      else if (val > max) max = val
      sum += val
      sum2 += val * val
    }

    return {len, numFinite: len, numNaN: 0, min, max, sum, sum2}
  }

  function summarizeString(series) {
    const values = series.values
    const len = series.length
    let minLength = null
    let maxLength = null

    for (let i = 0; i < len; ++i) {
      const val = values[i]
      const length = val.length
      if (minLength === null) minLength = maxLength = length
      else if (length < minLength) minLength = length
      else if (length > maxLength) maxLength = length
    }

    return {len, minLength, maxLength}
  }

  function summarize(series) {
    const values = series.values
    if (isFloatArray(values)) return summarizeFloat(series)
    else if (isIntArray(values)) return summarizeInt(series)
    else return summarizeString(series)  // FIXME
  }

  module.exports = {
    add: binary((a, b) => a + b, 'add'),
    sub: binary((a, b) => a - b, 'sub'),
    mul: binary((a, b) => a * b, 'mul'),
    div: binary((a, b) => a / b, 'div'),
    mod: binary((a, b) => a % b, 'mod'),

    sum: fold((a, b) => a + b, 0, 'sum'),

    cumsum: scan((a, b) => a + b, 0, 'cumsum'),

    filter,
    map,
    reduce,
    summarize,
  }
}).call(this)

