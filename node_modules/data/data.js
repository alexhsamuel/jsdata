(function () {
  const assert = require('assert')
  const binary_search = require('binary-search')

  const permutation = require('data/permutation')

  // FIXME
  function formatter(width, precision) {
    const pad = ' '.repeat(width)
    const len = width + precision + 1
    const fmt = num => (pad + num.toFixed(precision)).slice(-len)
    fmt.width = len
    return fmt
  }
  const FORMAT = formatter(4, 6)

  /**
   * A set of labels consisting of a sorted unique array of values.
   */
  class Key {
    constructor(labels, name) {
      assert(permutation.isSorted(labels))
      assert(permutation.isUnique(labels))
      this.labels = labels
      this.name = name
    }

    get length() { return this.labels.length }

    call(label) {
      const idx = binarySearch(this.labels, label, permutation.cmp)
      assert(idx >= 0)  // FIXME: Throw.
      return idx
    }

    get(label) { return call(label) }

    getAt(idx) {
      return this.labels[idx]
    }
  }

  class Series {
    constructor(labels, values, name) {
      assert.equal(labels.length, values.length)
      this.labels = labels
      this.values = values
      this.name = name
    }

    call(label) {
      const idx = this.labels.call(label)
      return this.values(idx)
    }

    get length() { return this.values.length }

    // FIXME: Is this reasonable?
    get key() { return this.labels instanceof Key ? this.labels : undefined }

    toString(labelFmt=FORMAT, fmt=FORMAT) {
      const lines = []

      // Header.
      lines.push(
        (this.labels.name + ' '.repeat(labelFmt.width)).slice(0, labelFmt.width)
        + ' | '
        + (this.name + ' '.repeat(fmt.width)).slice(0, fmt.width))
      // Underline.
      lines.push('='.repeat(labelFmt.width) + '=|-' + '-'.repeat(fmt.width))

      for (let i = 0; i < this.length; ++i)
        lines.push(
          labelFmt(this.labels.getAt(i)) + ' | ' + fmt(this.values[i]))
      return lines.join('\n')
    }

  }

  function makeSeries(labels, values, keyName, name) {
    assert.equal(labels.length, values.length)
    let sort
    [labels, sort] = permutation.sort(labels)
    values = permutation.permute(sort, values)
    return new Series(new Key(labels, keyName), values, name)
  }

  module.exports = {
    Key,
    Series,
    makeSeries,

    sample: makeSeries(
      [2, 5, 3, 1, 0], 
      [2.2, 5.5, 3.3, 1.1, 0.0],
      'index', 'value'),

  }

}).call(this)

