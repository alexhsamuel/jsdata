(function () {
  const _ = require('underscore')
  const assert = require('assert')
  const binary_search = require('binary-search')

  const permutation = require('data/permutation')

  // FIXME
  function formatter(width, precision) {
    const pad = ' '.repeat(width)
    const len = width + precision + 1
    const fmt = num => {
      if (Number.isFinite(num))
        return (pad + num.toFixed(precision)).slice(-len)
      else if (num) {
        const ret = num.toString()
        return ret + ' '.repeat(Math.max(0, len - ret.length))
      }
      else
        return ' '.repeat(len)
    }
    fmt.width = len
    return fmt
  }
  const FORMAT = formatter(8, 6)

  function pad(string, width, pad=' ', position=1) {
    string = string || ''
    assert(0 <= position && position <= 1)
    if (string.length < width) {
      const total = width - string.length
      const left = Math.round((1 - position) * total)
      return pad.repeat(left) + string + pad.repeat(total - left)
    }
    else return string
  }

  /**
   * A set of labels consisting of a sorted unique array of values.
   */
  class Key {
    constructor(labels) {
      assert(permutation.isSorted(labels))
      assert(permutation.isUnique(labels))
      this.labels = labels
    }

    get length() { return this.labels.length }

    call(label) {
      const idx = binarySearch(this.labels, label, permutation.cmp)
      assert(idx >= 0)  // FIXME: Throw.
      return idx
    }

    get(label) { return call(label) }

    getAt(idx) {
      return this.labels[idx]
    }
  }

  class Series {
    constructor(labels, values) {
      assert.equal(labels.length, values.length)
      this.labels = labels
      this.values = values
    }

    call(label) {
      const idx = this.labels.call(label)
      return this.values(idx)
    }

    get length() { return this.values.length }

    // FIXME: Is this reasonable?
    get key() { return this.labels instanceof Key ? this.labels : undefined }

    toString(labelFmt=FORMAT, fmt=FORMAT) {
      const lines = []

      // Header.
      lines.push(pad('key', labelFmt.width) + ' | ' + pad('value', fmt.width))
      // Underline.
      lines.push('='.repeat(labelFmt.width) + ' | ' + '-'.repeat(fmt.width))

      for (let i = 0; i < this.length; ++i)
        lines.push(
          labelFmt(this.labels.getAt(i)) + ' | ' + fmt(this.values[i]))
                 
      lines.push('')
      return lines.join('\n')
    }

  }

  function makeSeries(labels, values) {
    assert.equal(labels.length, values.length)
    let sort
    [labels, sort] = permutation.sort(labels)
    values = permutation.permute(sort, values)
    return new Series(new Key(labels), values)
  }

  class Table {
    constructor(labels, columns) {
      const len = labels.length
      this.labels = labels
      this.columns = columns

      this.cols = {}
      for (let [name, arr] of columns) 
        if (name)
          Object.defineProperty(
            this.cols, name, {get: () => new Series(this.labels, arr)})
        else
          console.warn('empty name')  // FIXME
    }

    get length() { return this.labels.length }
    get names() { return this.columns.map(([n, _]) => n) }
    get arrays() { return this.columns.map(([_, a]) => a) }
    
    // FIXME: Do better with formatters.
    toString(labelFmt=FORMAT, fmt=FORMAT) {
      const lines = []
      const keySep = ' | '

      // Header.
      lines.push(
        pad('key', labelFmt.width) + keySep
        + this.names.map(n => pad(n, fmt.width)).join(' '))
      // Underline
      lines.push(
        '='.repeat(labelFmt.width) + keySep
        + this.names.map(n => '-'.repeat(fmt.width)).join(' '))

      for (let i = 0; i < this.length; ++i)
        lines.push(
          labelFmt(this.labels.getAt(i)) + keySep
          + this.arrays.map(a => fmt(a[i])).join(' '))

      lines.push('')
      return lines.join('\n')
    }
    
  }
  

  module.exports = {
    Key,
    Series,
    Table,
    makeSeries,
  }

}).call(this)

